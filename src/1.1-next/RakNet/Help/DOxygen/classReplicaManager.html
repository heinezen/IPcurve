<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: ReplicaManager Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ReplicaManager Class Reference<br>
<small>
[<a class="el" href="group__REPLICA__MANAGER__GROUP.html">ReplicaManager</a>]</small>
</h1><!-- doxytag: class="ReplicaManager" --><!-- doxytag: inherits="PluginInterface" -->A management system for your game objects and players to make serialization, scoping, and object creation and destruction easier.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ReplicaManager.h&gt;</code>
<p>
<p>Inheritance diagram for ReplicaManager:
<p><center><img src="classReplicaManager.png" usemap="#ReplicaManager_map" border="0" alt=""></center>
<map name="ReplicaManager_map">
<area href="classPluginInterface.html" alt="PluginInterface" shape="rect" coords="0,0,105,24">
</map>
<a href="classReplicaManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<b>REPLICA_EXPLICIT_CONSTRUCTION</b> = 1&lt;&lt;0, 
<b>REPLICA_IMPLICIT_CONSTRUCTION</b> = 1&lt;&lt;1, 
<b>REPLICA_SCOPE_TRUE</b> = 1&lt;&lt;2, 
<b>REPLICA_SCOPE_FALSE</b> = 1&lt;&lt;3, 
<br>
&nbsp;&nbsp;<b>REPLICA_SERIALIZE</b> = 1&lt;&lt;4
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a699a030dde190e8f6a1fecbd83cb0e"></a><!-- doxytag: member="ReplicaManager::ReplicaManager" ref="8a699a030dde190e8f6a1fecbd83cb0e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#8a699a030dde190e8f6a1fecbd83cb0e">ReplicaManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d115c72f9422d93f500e8fe5a290d5b"></a><!-- doxytag: member="ReplicaManager::~ReplicaManager" ref="5d115c72f9422d93f500e8fe5a290d5b" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5d115c72f9422d93f500e8fe5a290d5b">~ReplicaManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#cfd1be4e145f3f11d02ee866fc5e737f">SetAutoParticipateNewConnections</a> (bool autoAdd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#264ae43e75a670348e5b3b79eb9f43c9">AddParticipant</a> (<a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#60df65ae84dede203baa04b432dc41a0">RemoveParticipant</a> (<a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#ce614cabcd21a90cbed8a7a775666433">Construct</a> (<a class="el" href="classReplica.html">Replica</a> *replica, bool isCopy, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#d9c9f2cd9e9496576a78c92049d80214">Destruct</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#083f4f17ab6924a5d3a6581b1093bcac">ReferencePointer</a> (<a class="el" href="classReplica.html">Replica</a> *replica)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#f14904b4d245d7202a1ab7c41a909a4c">DereferencePointer</a> (<a class="el" href="classReplica.html">Replica</a> *replica)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#d63c303bd6fb995dd8e52c0e84998f3c">SetScope</a> (<a class="el" href="classReplica.html">Replica</a> *replica, bool inScope, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#1dba75dce05f3f559c97ffd1b21930d4">SignalSerializeNeeded</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#08cf47d286e7969808d4024d9ae0f2b0">SetReceiveConstructionCB</a> (<a class="el" href="classReceiveConstructionInterface.html">ReceiveConstructionInterface</a> *receiveConstructionInterface)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#c053a9655afbc6b651bbdb2e91f76d76">SetDownloadCompleteCB</a> (<a class="el" href="classSendDownloadCompleteInterface.html">SendDownloadCompleteInterface</a> *sendDownloadComplete, <a class="el" href="classReceiveDownloadCompleteInterface.html">ReceiveDownloadCompleteInterface</a> *receiveDownloadComplete)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#1b21ec1b0f07c7bce29600db7cbada96">SetSendChannel</a> (unsigned char channel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#0549b1458909abc29a0396e63b5a4868">SetAutoConstructToNewParticipants</a> (bool autoConstruct)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#011ed89662e5aacbf30aeb6e7b4fdcd9">SetDefaultScope</a> (bool scope)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#3c6e37d0c17c3d5458c194514b2404df">SetAutoSerializeInScope</a> (bool autoSerialize)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5658bc1437932f065a27ec4d61017424">EnableReplicaInterfaces</a> (<a class="el" href="classReplica.html">Replica</a> *replica, unsigned char interfaceFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5201542199e51922dd53c4f0249dc86a">DisableReplicaInterfaces</a> (<a class="el" href="classReplica.html">Replica</a> *replica, unsigned char interfaceFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#86fb88120169609d30dc2c67158b739d">IsConstructed</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#3cdcc0520424e9188ec461daf75e78ae">IsInScope</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#7a307b91ce71e0fa08bbea32760532ef">GetReplicaAtIndex</a> (unsigned index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#1e91709cde0d44789601e9c30cc23cf4">GetParticipantCount</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#3762c610910be8cf052af74b63c691b1">GetParticipantAtIndex</a> (unsigned index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#67082399041a7042373a1ae4ed5bebbc">HasParticipant</a> (<a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#b24556810cd7362fd3f70833ff811c78">SignalSerializationFlags</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast, bool set, unsigned int flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#9c6b5b7a5e6332fb17e74ab103739d04">AccessSerializationFlags</a> (<a class="el" href="classReplica.html">Replica</a> *replica, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a4cbca22448781b6340ad40c7d04cab"></a><!-- doxytag: member="ReplicaManager::RegisteredReplicaComp" ref="4a4cbca22448781b6340ad40c7d04cab" args="(Replica *const &amp;key, const ReplicaManager::RegisteredReplica &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisteredReplicaComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::RegisteredReplica &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba5fd98c057e6b0ca4381490d8c11ef4"></a><!-- doxytag: member="ReplicaManager::RemoteObjectComp" ref="ba5fd98c057e6b0ca4381490d8c11ef4" args="(Replica *const &amp;key, const ReplicaManager::RemoteObject &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoteObjectComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::RemoteObject &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d79d7a457d712d262ed70cddc9270d0"></a><!-- doxytag: member="ReplicaManager::CommandStructComp" ref="3d79d7a457d712d262ed70cddc9270d0" args="(Replica *const &amp;key, const ReplicaManager::CommandStruct &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandStructComp</b> (<a class="el" href="classReplica.html">Replica</a> *const &amp;key, const ReplicaManager::CommandStruct &amp;data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a8e92dad56513dcee0d01c9e7fec589"></a><!-- doxytag: member="ReplicaManager::ParticipantStructComp" ref="6a8e92dad56513dcee0d01c9e7fec589" args="(const SystemAddress &amp;key, ReplicaManager::ParticipantStruct *const &amp;data)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>ParticipantStructComp</b> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> &amp;key, ReplicaManager::ParticipantStruct *const &amp;data)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6545f9a24d8086e738bc8ec4c56d17d3"></a><!-- doxytag: member="ReplicaManager::Clear" ref="6545f9a24d8086e738bc8ec4c56d17d3" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#6545f9a24d8086e738bc8ec4c56d17d3">Clear</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all memory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f67c84ca14d99a1f5e7e5d2439ad68f5"></a><!-- doxytag: member="ReplicaManager::ProcessReceivedCommand" ref="f67c84ca14d99a1f5e7e5d2439ad68f5" args="(ParticipantStruct *participantStruct, ReceivedCommand *receivedCommand)" -->
<a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ProcessReceivedCommand</b> (ParticipantStruct *participantStruct, ReceivedCommand *receivedCommand)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#35dfe3841d8cfc5b78174f11251acac6">Update</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#41deec3843e868c185b946091694843f">OnAttach</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PluginReceiveResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#ad65d9a5c4de623dc1e17f8ef3b44fd8">OnReceive</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structPacket.html">Packet</a> *packet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#062d19e7c858e81aed8f95588d4eef3f">OnCloseConnection</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#5f3e3f2e32cd211102cc49d2b2e4d238">OnShutdown</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ec5e39a112eac01e973aae210e6e38a"></a><!-- doxytag: member="ReplicaManager::GetParticipantBySystemAddress" ref="1ec5e39a112eac01e973aae210e6e38a" args="(const SystemAddress systemAddress) const " -->
ParticipantStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParticipantBySystemAddress</b> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<br>
 <a class="el" href="classReplica.html">Replica</a> *, RegisteredReplica,<br>
 ReplicaManager::RegisteredReplicaComp &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#157a22e5a3ae38376d11cd7da7bd249e">replicatedObjects</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<br>
 <a class="el" href="structSystemAddress.html">SystemAddress</a>, ParticipantStruct *,<br>
 ReplicaManager::ParticipantStructComp &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplicaManager.html#acacdbd603c5361fe180710b7a8d856f">participantList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87f1464d9aebeb8a1823d13e413f6874"></a><!-- doxytag: member="ReplicaManager::_constructionCB" ref="87f1464d9aebeb8a1823d13e413f6874" args="" -->
<a class="el" href="classReceiveConstructionInterface.html">ReceiveConstructionInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>_constructionCB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89148b10576b910112167e05b7a80a95"></a><!-- doxytag: member="ReplicaManager::_sendDownloadCompleteCB" ref="89148b10576b910112167e05b7a80a95" args="" -->
<a class="el" href="classSendDownloadCompleteInterface.html">SendDownloadCompleteInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sendDownloadCompleteCB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b51757925ab803d647743688f5fdbfdf"></a><!-- doxytag: member="ReplicaManager::_receiveDownloadCompleteCB" ref="b51757925ab803d647743688f5fdbfdf" args="" -->
<a class="el" href="classReceiveDownloadCompleteInterface.html">ReceiveDownloadCompleteInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>_receiveDownloadCompleteCB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73ee075ec3957ffb20efa1c150d595fa"></a><!-- doxytag: member="ReplicaManager::sendChannel" ref="73ee075ec3957ffb20efa1c150d595fa" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>sendChannel</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="036f4fa0fc0cad2a3b4fd3e3a0933a2d"></a><!-- doxytag: member="ReplicaManager::autoParticipateNewConnections" ref="036f4fa0fc0cad2a3b4fd3e3a0933a2d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>autoParticipateNewConnections</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69aaa76b70dc080119f3fc7fe0aeb942"></a><!-- doxytag: member="ReplicaManager::autoSerializeInScope" ref="69aaa76b70dc080119f3fc7fe0aeb942" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>autoSerializeInScope</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1f5c5711d9c134b78ebc613252610c4"></a><!-- doxytag: member="ReplicaManager::defaultScope" ref="e1f5c5711d9c134b78ebc613252610c4" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>defaultScope</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c4bc10be5b05b2f5a2e182f33f13aaa"></a><!-- doxytag: member="ReplicaManager::autoConstructToNewParticipants" ref="3c4bc10be5b05b2f5a2e182f33f13aaa" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>autoConstructToNewParticipants</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ef6e1a5408b2606665e956e775640de"></a><!-- doxytag: member="ReplicaManager::rakPeer" ref="6ef6e1a5408b2606665e956e775640de" args="" -->
<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>rakPeer</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ParticipantStruct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ReceivedCommand</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisteredReplica</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoteObject</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A management system for your game objects and players to make serialization, scoping, and object creation and destruction easier. 
<p>
<a class="el" href="classReplicaManager.html">ReplicaManager</a> is a system manager for your game objects that performs the following tasks: 1. Tracks all locally registered game objects and players and only performs operations to and for those objects and players 2. Allows you to automatically turn off unneeded local and remote functions for your game objects, thus providing convenience and security against unauthorized sends. 3. Sends notifications of existing game objects to new connections, including a download complete message. 4. Sends notifications of new game objects to existing players. A. Serialize and scoping calls are not sent to objects that were not notified of that object. B. Notification calls can be canceled on a per-object basis. Object notification sends are tracked on a per-system per-object basis. 5. Configurable per-system per-object scoping. A. Scoping provides a mechanism to hide and unhide remote objects without destroying the whole object, used when when entities should not be destroyed but are currently not visible to systems. B. Serialize calls are not sent to hidden objects. C. Scoping calls can be canceled on a per-object basis. Scope is tracked on a per-system per-object basis. 6. Replicate, SetScope, SignalSerializeNeeded, and the corresponding <a class="el" href="classReplica.html">Replica</a> interfaces are processed in <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">RakPeer::Receive</a>, rather than immediately. A. This allows the <a class="el" href="classReplicaManager.html">ReplicaManager</a> to reorganize function calls in order by dependency. This allows out of order calls, per-object call cancellation (which also cancels dependencies), and per-object call delays (which also delays dependencies) B. For example, although SetScope and SignalSerializeNeeded have a dependency on SetNetworkID(), you can still call them in the constructor and call SetNetworkID() later, as long as it happens before calling <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">RakPeer::Receive()</a> 7. The system is fast, uses little memory, and is intentionally hands off such that it can work with any game architecture and network topology<p>
What the <a class="el" href="classReplicaManager.html">ReplicaManager</a> system does NOT do for you 1. Actually create or destroy your game objects 2. Associate object destruction events with remote system disconnects. 3. Set networkIDs via SetNetworkID() on newly created objects. 4. Object sub-serialization. Serialize only granular on the level of entire objects. If you want to serialize part of the object, you need to set your own flags and indicate in the BitStream which parts were sent and which not. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>You must call <a class="el" href="group__RAKNET__RPC.html#g3dd3a014e7e3ab37489fdc3d9c77d072">RakPeer::SetNetworkIDManager</a> to use this plugin. </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cfd1be4e145f3f11d02ee866fc5e737f"></a><!-- doxytag: member="ReplicaManager::SetAutoParticipateNewConnections" ref="cfd1be4e145f3f11d02ee866fc5e737f" args="(bool autoAdd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetAutoParticipateNewConnections           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoAdd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Do or don't automatically call AddParticipant when new systems connect to us. Won't add automatically add connections that already exist before this was called Defaults to false <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoAdd</em>&nbsp;</td><td>True or false, to add or not </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="264ae43e75a670348e5b3b79eb9f43c9"></a><!-- doxytag: member="ReplicaManager::AddParticipant" ref="264ae43e75a670348e5b3b79eb9f43c9" args="(SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplicaManager::AddParticipant           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a participant to the <a class="el" href="classReplicaManager.html">ReplicaManager</a> system. Only these participants get packets and we only accept <a class="el" href="classReplicaManager.html">ReplicaManager</a> packets from these participants. This way you can have connections that have nothing to do with your game - for example remote console logins <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which player you are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on participant already exists </dd></dl>

</div>
</div><p>
<a class="anchor" name="60df65ae84dede203baa04b432dc41a0"></a><!-- doxytag: member="ReplicaManager::RemoveParticipant" ref="60df65ae84dede203baa04b432dc41a0" args="(SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplicaManager::RemoveParticipant           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a participant from the data replicator system This is called automatically on ID_DISCONNECTION_NOTIFICATION and ID_CONNECTION_LOST messages, as well as CloseConnection() calls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which player you are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on participant does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce614cabcd21a90cbed8a7a775666433"></a><!-- doxytag: member="ReplicaManager::Construct" ref="ce614cabcd21a90cbed8a7a775666433" args="(Replica *replica, bool isCopy, SystemAddress systemAddress, bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::Construct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct the specified object on the specified system <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> will be called on the next update cycle for the player you specify Nothing is actually created - this just signals that another system wants you to do so. The other system will get Replica::ReceiveConstruction If your system assigns NetworkIDs, do so before calling Replicate as the NetworkID is automatically included in the packet. Replicate packets that are sent to systems that already have this NetworkID are ignored. <dl class="note" compact><dt><b>Note:</b></dt><dd>Objects which are replicated get exactly one call to SendConstruction for every player / object permutation. <p>
To perform scoping and serialize updates on an object already created by another system, call Construct with <em>isCopy</em> true. <p>
Setting <em>isCopy</em> true will consider the object created on that system without actually trying to create it. <p>
If you don't need to send updates to other systems for this object, it is more efficient to use ReferencePointer instead. <p>
In a client / server environment, be sure to call <a class="el" href="classReplicaManager.html#ce614cabcd21a90cbed8a7a775666433">Construct()</a> with isCopy true to let the <a class="el" href="classReplicaManager.html">ReplicaManager</a> know that the server has this object. Otherwise you won't be able to send Scope or Serialize changes to the server. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isCopy</em>&nbsp;</td><td>True means that this is a copy of an object that already exists on the systems specified by <em>systemAddress</em> and <em>broadcast</em>. If true, we will consider these systems as having the object without sending a datagram to them. SendConstruction will NOT be called for objects which <em>isCopy</em> is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If systemAddress!=UNASSIGNED_SYSTEM_ADDRESS then this means send to all but that participant </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9c9f2cd9e9496576a78c92049d80214"></a><!-- doxytag: member="ReplicaManager::Destruct" ref="d9c9f2cd9e9496576a78c92049d80214" args="(Replica *replica, SystemAddress systemAddress, bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::Destruct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this with your game objects to have them send <a class="el" href="classReplica.html#740fc653aa0415b3d62677723477ed45">Replica::SendDestruction</a>. This will be sent immediately to all participants that have this object. Those participants will get <a class="el" href="classReplica.html#0e29c6f3e7118f094cbcd424e2f374d0">Replica::ReceiveDestruction</a> All pending calls for this object, for this player, are canceled. Nothing is actually deleted - this just signals that the other system called this function. It is up to you to actually delete your object. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, SetNetworkID on that object must have been called with the same value as GetNetworkID for this object. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Call Destruct before DereferencePointer if you plan on calling both, since Destruct will fail with no pointer reference. <p>
Calling ( with systemAddress==UNASSIGNED_SYSTEM_ADDRESS and broadcast true is equivalent to calling DereferencePointer except that Destruct also sends the destruct packet. <p>
It is important to call this before deleting your object. Otherwise this system will crash the next Update call. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If systemAddress!=UNASSIGNED_SYSTEM_ADDRESS then this means send to all but that participant </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="083f4f17ab6924a5d3a6581b1093bcac"></a><!-- doxytag: member="ReplicaManager::ReferencePointer" ref="083f4f17ab6924a5d3a6581b1093bcac" args="(Replica *replica)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::ReferencePointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This makes sure the object is tracked, so you can get calls on it. This will automatically happen if you call Construct, SetScope, or SignalSerializeNeeded with <em>replica</em> Otherwise you need to call this, or for security the system will ignore calls that reference this object, even if given a valid NetworkID Duplicate calls are safe and are simply ignored. Best place to put this is in the SetReceiveConstructionCB callback so that all your objects are registered. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
  </table>
</dl>

<p>
Try setting the network ID manager if the user forgot 
</div>
</div><p>
<a class="anchor" name="f14904b4d245d7202a1ab7c41a909a4c"></a><!-- doxytag: member="ReplicaManager::DereferencePointer" ref="f14904b4d245d7202a1ab7c41a909a4c" args="(Replica *replica)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::DereferencePointer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this before you delete <em>replica</em>. This locally removes all references to this pointer. No messages are sent. Best place to put this is in the destructor of <em>replica</em> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>A pointer to your object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d63c303bd6fb995dd8e52c0e84998f3c"></a><!-- doxytag: member="ReplicaManager::SetScope" ref="d63c303bd6fb995dd8e52c0e84998f3c" args="(Replica *replica, bool inScope, SystemAddress systemAddress, bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the scope of your object in relation to another participant. Objects that are in-scope for that participant will send out <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a> calls. Otherwise Serialize calls are not sent. Scoping is useful when you want to disable sends to an object temporarily, without deleting that object. Calling this results in <a class="el" href="classReplica.html#23a61fd40c4c111376c758cb5c062932">Replica::SendScopeChange</a> being called on the local object and <a class="el" href="classReplica.html#9077bbe9b0a2e4804be48e2f5119ccb0">Replica::ReceiveScopeChange</a> on the remote object if that object has been created on that remote system. Your game should ensure that objects not in scope are hidden, but not deallocated, on the remote system. <a class="el" href="classReplica.html#23a61fd40c4c111376c758cb5c062932">Replica::SendScopeChange</a> with <em>inScope</em> as true will automatically perform <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a> <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, that object must have an NetworkID (set by SetNetworkID()) the same as our object's NetworkID (returned from GetNetworkID()). </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You can set the default scope with <a class="el" href="classReplicaManager.html#011ed89662e5aacbf30aeb6e7b4fdcd9">SetDefaultScope()</a> <p>
Individual objects can refuse to perform the SendScopeChange call by not writing to the output bitstream while returning true. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inScope</em>&nbsp;</td><td>in scope or not. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If systemAddress!=UNASSIGNED_SYSTEM_ADDRESS then this means send to all but that participant </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1dba75dce05f3f559c97ffd1b21930d4"></a><!-- doxytag: member="ReplicaManager::SignalSerializeNeeded" ref="1dba75dce05f3f559c97ffd1b21930d4" args="(Replica *replica, SystemAddress systemAddress, bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SignalSerializeNeeded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal that data has changed and we need to call Serialize() on the <em>replica</em> object. This will happen if the object has been registered, <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> wrote to outBitStream and returned true, and the object is in scope for this player. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Call Replicate with this object first. <p>
For the other system to get the network message, that object must have an NetworkID (set by SetNetworkID()) the same as our object's NetworkID (returned from GetNetworkID()). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send the command to, or the one to exclude if broadcast is true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send to all. If systemAddress!=UNASSIGNED_SYSTEM_ADDRESS then this means send to all but that participant </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="08cf47d286e7969808d4024d9ae0f2b0"></a><!-- doxytag: member="ReplicaManager::SetReceiveConstructionCB" ref="08cf47d286e7969808d4024d9ae0f2b0" args="(ReceiveConstructionInterface *receiveConstructionInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetReceiveConstructionCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReceiveConstructionInterface.html">ReceiveConstructionInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>receiveConstructionInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Required callback Set your callback to parse requests to create new objects. Specifically, when <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> is called and the networkID of the object is either unset or can't be found, this callback will get that call. How do you know what object to create? It's up to you, but I suggest in <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> you encode the class name. The best way to do this is with the <a class="el" href="classStringTable.html">StringTable</a> class. <dl class="note" compact><dt><b>Note:</b></dt><dd>If you return true from <a class="el" href="classNetworkIDManager.html#36a985a593125a496d09e7978dc3777e">NetworkIDManager::IsNetworkIDAuthority</a>, which you should do for a server or peer, I recommend also encoding the value returned by GetNetworkID() within <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> into that bitstream and reading it here. Then set that value in a call to SetNetworkID. Dereplicate, SetScope, and SignalSerializeNeeded all rely on being able to call GET_OBJECT_FROM_ID which requires that SetNetworkID be called on that object. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em><a class="el" href="classReceiveConstructionInterface.html">ReceiveConstructionInterface</a></em>&nbsp;</td><td>An instance of a class that implements <a class="el" href="classReceiveConstructionInterface.html">ReceiveConstructionInterface</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c053a9655afbc6b651bbdb2e91f76d76"></a><!-- doxytag: member="ReplicaManager::SetDownloadCompleteCB" ref="c053a9655afbc6b651bbdb2e91f76d76" args="(SendDownloadCompleteInterface *sendDownloadComplete, ReceiveDownloadCompleteInterface *receiveDownloadComplete)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetDownloadCompleteCB           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSendDownloadCompleteInterface.html">SendDownloadCompleteInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>sendDownloadComplete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReceiveDownloadCompleteInterface.html">ReceiveDownloadCompleteInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>receiveDownloadComplete</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set your callbacks to be called when, after connecting to another system, you get all objects that system is going to send to you when it is done with the first iteration through the object list. Optional if you want to send and receive the download complete notification <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendDownloadComplete</em>&nbsp;</td><td>A class that implements the <a class="el" href="classSendDownloadCompleteInterface.html">SendDownloadCompleteInterface</a> interface. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>receiveDownloadComplete</em>&nbsp;</td><td>A class that implements the <a class="el" href="classReceiveDownloadCompleteInterface.html">ReceiveDownloadCompleteInterface</a> interface. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classSendDownloadCompleteInterface.html">SendDownloadCompleteInterface</a> , <a class="el" href="classReceiveDownloadCompleteInterface.html">ReceiveDownloadCompleteInterface</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b21ec1b0f07c7bce29600db7cbada96"></a><!-- doxytag: member="ReplicaManager::SetSendChannel" ref="1b21ec1b0f07c7bce29600db7cbada96" args="(unsigned char channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetSendChannel           </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This channel will be used for all <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send</a> calls <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel to use for internal <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send</a> calls from this system. Defaults to 0. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0549b1458909abc29a0396e63b5a4868"></a><!-- doxytag: member="ReplicaManager::SetAutoConstructToNewParticipants" ref="0549b1458909abc29a0396e63b5a4868" args="(bool autoConstruct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetAutoConstructToNewParticipants           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoConstruct</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This means automatically construct all known objects to all new participants Has no effect on existing participants Useful if your architecture always has all objects constructed on all systems all the time anyway, or if you want them to normally start constructed Defaults to false. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoConstruct</em>&nbsp;</td><td>true or false, as desired. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="011ed89662e5aacbf30aeb6e7b4fdcd9"></a><!-- doxytag: member="ReplicaManager::SetDefaultScope" ref="011ed89662e5aacbf30aeb6e7b4fdcd9" args="(bool scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetDefaultScope           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>scope</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default scope for new objects to all players. Defaults to false, which means Serialize will not be called for new objects automatically. If you set this to true, then new players will get existing objects, and new objects will be sent to existing players This only applies to players that connect and objects that are replicated after this call. Existing object scopes are not affected. Useful to set to true if you don't use scope, or if all objects normally start in scope <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scope</em>&nbsp;</td><td>The default scope to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3c6e37d0c17c3d5458c194514b2404df"></a><!-- doxytag: member="ReplicaManager::SetAutoSerializeInScope" ref="3c6e37d0c17c3d5458c194514b2404df" args="(bool autoSerialize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SetAutoSerializeInScope           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoSerialize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When an object goes in scope for a system, you normally want to serialize that object to that system. Setting this flag to true will call Serialize for you automatically when SendScopeChange returns REPLICA_PROCESSING_DONE and the scopeTrue parameter is true Defaults to false <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autoSerialize</em>&nbsp;</td><td>True or false as needed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5658bc1437932f065a27ec4d61017424"></a><!-- doxytag: member="ReplicaManager::EnableReplicaInterfaces" ref="5658bc1437932f065a27ec4d61017424" args="(Replica *replica, unsigned char interfaceFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::EnableReplicaInterfaces           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>interfaceFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lets you enable calling any or all of the interface functions in an instance of <a class="el" href="classReplica.html">Replica</a> This setting is the same for all participants for this object, so if you want per-participant permissions you will need to handle that inside your implementation All functions enabled by default. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object you are referring to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interfaceFlags</em>&nbsp;</td><td>A bitwise-OR of REPLICA_SEND_CONSTRUCTION ... REPLICA_SET_ALL corresponding to the function of the same name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5201542199e51922dd53c4f0249dc86a"></a><!-- doxytag: member="ReplicaManager::DisableReplicaInterfaces" ref="5201542199e51922dd53c4f0249dc86a" args="(Replica *replica, unsigned char interfaceFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::DisableReplicaInterfaces           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>interfaceFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lets you disable calling any or all of the interface functions in an instance of <a class="el" href="classReplica.html">Replica</a> This setting is the same for all participants for this object, so if you want per-participant permissions you will need to handle that inside your implementation All functions enabled by default. <dl class="note" compact><dt><b>Note:</b></dt><dd>Disabling functions is very useful for security. <p>
For example, on the server you may wish to disable all receive functions so clients cannot change server objects. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object you are referring to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interfaceFlags</em>&nbsp;</td><td>A bitwise-OR of REPLICA_SEND_CONSTRUCTION ... REPLICA_SET_ALL corresponding to the function of the same name </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86fb88120169609d30dc2c67158b739d"></a><!-- doxytag: member="ReplicaManager::IsConstructed" ref="86fb88120169609d30dc2c67158b739d" args="(Replica *replica, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplicaManager::IsConstructed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells us if a particular system got a SendConstruction() message from this object. e.g. does this object exist on this remote system? This is set by the user when calling Replicate and sending (any) data to outBitStream in <a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">Replica::SendConstruction</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object we are checking </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The system we are checking </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3cdcc0520424e9188ec461daf75e78ae"></a><!-- doxytag: member="ReplicaManager::IsInScope" ref="3cdcc0520424e9188ec461daf75e78ae" args="(Replica *replica, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplicaManager::IsInScope           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells us if a particular object is in scope for a particular system This is set by the user when calling SetScope and sending (any) data to outBitstream in <a class="el" href="classReplica.html#23a61fd40c4c111376c758cb5c062932">Replica::SendScopeChange</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>The object we are checking </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The system we are checking </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99b46ca5a05affea7b783d08c0c962da"></a><!-- doxytag: member="ReplicaManager::GetReplicaCount" ref="99b46ca5a05affea7b783d08c0c962da" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ReplicaManager::GetReplicaCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns how many <a class="el" href="classReplica.html">Replica</a> instances are registered. This number goes up with each non-duplicate call to Replicate and down with each non-duplicate call to Dereplicate Used for GetReplicaAtIndex if you want to perform some object on all registered <a class="el" href="classReplica.html">Replica</a> objects. <dl class="return" compact><dt><b>Returns:</b></dt><dd>How many replica objects are in the list of replica objects </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a307b91ce71e0fa08bbea32760532ef"></a><!-- doxytag: member="ReplicaManager::GetReplicaAtIndex" ref="7a307b91ce71e0fa08bbea32760532ef" args="(unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReplica.html">Replica</a> * ReplicaManager::GetReplicaAtIndex           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a previously registered <a class="el" href="classReplica.html">Replica</a> *, from index 0 to <a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount()</a>-1. The order that <a class="el" href="classReplica.html">Replica</a> * objects are returned in is arbitrary (it currently happens to be ordered by pointer address). Calling Dereplicate immediately deletes the <a class="el" href="classReplica.html">Replica</a> * passed to it, so if you call Dereplicate while using this function the array will be shifted over and the current index will now reference the next object in the array, if there was one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>An index, from 0 to <a class="el" href="classReplicaManager.html#99b46ca5a05affea7b783d08c0c962da">GetReplicaCount()</a>-1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classReplica.html">Replica</a> * previously passed to <a class="el" href="classReplicaManager.html#ce614cabcd21a90cbed8a7a775666433">Construct()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e91709cde0d44789601e9c30cc23cf4"></a><!-- doxytag: member="ReplicaManager::GetParticipantCount" ref="1e91709cde0d44789601e9c30cc23cf4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ReplicaManager::GetParticipantCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of unique participants added with AddParticipant As these systems disconnect, they are no longer participants, so this accurately returns how many participants are using the system <dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of unique participants added with AddParticipant </dd></dl>

</div>
</div><p>
<a class="anchor" name="3762c610910be8cf052af74b63c691b1"></a><!-- doxytag: member="ReplicaManager::GetParticipantAtIndex" ref="3762c610910be8cf052af74b63c691b1" args="(unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> ReplicaManager::GetParticipantAtIndex           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a <a class="el" href="structSystemAddress.html">SystemAddress</a> previously added with AddParticipant <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>An index, from 0 to <a class="el" href="classReplicaManager.html#1e91709cde0d44789601e9c30cc23cf4">GetParticipantCount()</a>-1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="structSystemAddress.html">SystemAddress</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="67082399041a7042373a1ae4ed5bebbc"></a><!-- doxytag: member="ReplicaManager::HasParticipant" ref="67082399041a7042373a1ae4ed5bebbc" args="(SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplicaManager::HasParticipant           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if a participant has been added <dl class="return" compact><dt><b>Returns:</b></dt><dd>If this participant has been added </dd></dl>

</div>
</div><p>
<a class="anchor" name="b24556810cd7362fd3f70833ff811c78"></a><!-- doxytag: member="ReplicaManager::SignalSerializationFlags" ref="b24556810cd7362fd3f70833ff811c78" args="(Replica *replica, SystemAddress systemAddress, bool broadcast, bool set, unsigned int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::SignalSerializationFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Each participant has a per-remote object bitfield passed to the <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a> call. This function can set or unset these flags for one or more participants at the same time. Flags are NOT automatically cleared on serialize. You must clear them when you want to do so. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to set the flags for </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to apply to all participants. If systemAddress!=UNASSIGNED_SYSTEM_ADDRESS then this means send to all but that participant </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>True set the bits set in <em>flags</em> with the per-object per-system serialization flags. False to unset these bits. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Modifier to the Per-object per-system flags sent to <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a>. See the parameter /a set </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9c6b5b7a5e6332fb17e74ab103739d04"></a><!-- doxytag: member="ReplicaManager::AccessSerializationFlags" ref="9c6b5b7a5e6332fb17e74ab103739d04" args="(Replica *replica, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int * ReplicaManager::AccessSerializationFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReplica.html">Replica</a> *&nbsp;</td>
          <td class="paramname"> <em>replica</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Each participant has a per-remote object bitfield passed to the <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a> call. This function is used to read and change these flags directly for a single participant. It gives more control than SignalSerializationFlags but only works for a single participant at a time. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replica</em>&nbsp;</td><td>An object previously registered with Replicate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to read/write the flags for </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the per-object per-system flags sent to <a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Replica::Serialize</a>. You can read or modify the flags directly with this function. This pointer is only valid until the next call to <a class="el" href="classRakPeer.html#30f9b6c0108bae2b860776136f6aece7">RakPeer::Receive</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35dfe3841d8cfc5b78174f11251acac6"></a><!-- doxytag: member="ReplicaManager::Update" ref="35dfe3841d8cfc5b78174f11251acac6" args="(RakPeerInterface *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::Update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update is called every time a packet is checked for . <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>- the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#5966e72f872ebd754b44770ecc981bd9">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="41deec3843e868c185b946091694843f"></a><!-- doxytag: member="ReplicaManager::OnAttach" ref="41deec3843e868c185b946091694843f" args="(RakPeerInterface *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::OnAttach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the interface is attached <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#9124155ea27bf6c50801350d21173d68">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="ad65d9a5c4de623dc1e17f8ef3b44fd8"></a><!-- doxytag: member="ReplicaManager::OnReceive" ref="ad65d9a5c4de623dc1e17f8ef3b44fd8" args="(RakPeerInterface *peer, Packet *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PluginReceiveResult ReplicaManager::OnReceive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OnReceive is called for every packet. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>the packet that is being returned to the user </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True to allow the game and other plugins to get this message, false to absorb it </dd></dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#633dcfc264e4309c41f0cfeb84b4840a">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="062d19e7c858e81aed8f95588d4eef3f"></a><!-- doxytag: member="ReplicaManager::OnCloseConnection" ref="062d19e7c858e81aed8f95588d4eef3f" args="(RakPeerInterface *peer, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::OnCloseConnection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a connection is dropped because the user called <a class="el" href="classRakPeer.html#05e43a9ba3b85f1000adb2f1e9551000">RakPeer::CloseConnection()</a> for a particular system <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The system whose connection was closed </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#da6d76a81fb6ea6dd8422c3ed5c9baff">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="5f3e3f2e32cd211102cc49d2b2e4d238"></a><!-- doxytag: member="ReplicaManager::OnShutdown" ref="5f3e3f2e32cd211102cc49d2b2e4d238" args="(RakPeerInterface *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReplicaManager::OnShutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="classRakPeer.html">RakPeer</a> is shutdown <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#0983119975a8bb9c726b8a006c089dc2">PluginInterface</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="157a22e5a3ae38376d11cd7da7bd249e"></a><!-- doxytag: member="ReplicaManager::replicatedObjects" ref="157a22e5a3ae38376d11cd7da7bd249e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<a class="el" href="classReplica.html">Replica</a> *, RegisteredReplica, ReplicaManager::RegisteredReplicaComp&gt; <a class="el" href="classReplicaManager.html#157a22e5a3ae38376d11cd7da7bd249e">ReplicaManager::replicatedObjects</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of objects replicated in the Replicate function. Used to make sure queued actions happen on valid pointers, since objects are removed from the list in Dereplicate Sorted by raw pointer address using the default sort 
</div>
</div><p>
<a class="anchor" name="acacdbd603c5361fe180710b7a8d856f"></a><!-- doxytag: member="ReplicaManager::participantList" ref="acacdbd603c5361fe180710b7a8d856f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataStructures_1_1OrderedList.html">DataStructures::OrderedList</a>&lt;<a class="el" href="structSystemAddress.html">SystemAddress</a>, ParticipantStruct *, ReplicaManager::ParticipantStructComp&gt; <a class="el" href="classReplicaManager.html#acacdbd603c5361fe180710b7a8d856f">ReplicaManager::participantList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of participants Each participant has several queues of pending commands Sorted by systemAddress The only complexity is that each participant also needs a list of objects that mirror the variable replicatedObjects so we know per-player if that object is in scope 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/RakNet/Source/<a class="el" href="ReplicaManager_8h.html">ReplicaManager.h</a><li>C:/RakNet/Source/ReplicaManager.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Feb 15 01:46:47 2007 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
