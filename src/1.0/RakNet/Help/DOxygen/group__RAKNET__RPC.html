<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: Remote Procedure Call Subsystem</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Remote Procedure Call Subsystem</h1>A system to call C or object member procudures on other systems, and even to return return values.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RPCMap_8h.html">RPCMap.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b></b>[Internal] A container class for a list of RPCNodes <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="RPCNode_8h.html">RPCNode.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b></b>[Internal] Holds information related to a RPC <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RPCMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RPCNode</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#ge8725bfeccab05a3422cde0923f176b3">REGISTER_STATIC_RPC</a>(networkObject, functionName)&nbsp;&nbsp;&nbsp;(networkObject)-&gt;RegisterAsRemoteProcedureCall((#functionName),(functionName))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RPC Function Implementation.  <a href="#ge8725bfeccab05a3422cde0923f176b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcdb86b76f825bec13557202fff8fbab1"></a><!-- doxytag: member="RAKNET_RPC::CLASS_MEMBER_ID" ref="gcdb86b76f825bec13557202fff8fbab1" args="(className, functionName)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gcdb86b76f825bec13557202fff8fbab1">CLASS_MEMBER_ID</a>(className, functionName)&nbsp;&nbsp;&nbsp;#className &quot;_&quot; #functionName</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate two strings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g70705f68c378bfaf9d854de1fe55431d">REGISTER_CLASS_MEMBER_RPC</a>(networkObject, className, functionName)&nbsp;&nbsp;&nbsp;{union {void (__cdecl className::*cFunc)( <a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms ); void* voidFunc;}; cFunc=&amp;className::functionName; networkObject-&gt;RegisterClassMemberRPC(CLASS_MEMBER_ID(className, functionName),voidFunc);}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a member function of an instantiated object as a Remote procedure call. RPC member Functions MUST be marked __cdecl!  <a href="#g70705f68c378bfaf9d854de1fe55431d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gdf209f7aefd451d95a1f322bd80295ed">UNREGISTER_STATIC_RPC</a>(networkObject, functionName)&nbsp;&nbsp;&nbsp;(networkObject)-&gt;UnregisterAsRemoteProcedureCall((#functionName))</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41">RakPeer::RegisterAsRemoteProcedureCall</a> (const char *uniqueID, void(*functionPointer)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gbd4e89c774e58f88754dfd6108b9c7d0">RakPeer::RegisterClassMemberRPC</a> (const char *uniqueID, void *functionPointer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g8d3118ee980a05022b9dd53a54b1f139">RakPeer::UnregisterAsRemoteProcedureCall</a> (const char *uniqueID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g3dd3a014e7e3ab37489fdc3d9c77d072">RakPeer::SetNetworkIDManager</a> (<a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *manager)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g555a4471b9cc061f2253817e35561f0f">RakPeer::RPC</a> (const char *uniqueID, const char *data, unsigned int bitLength, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gb07776a842829a0e911354e5657345d3">RakPeer::RPC</a> (const char *uniqueID, const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g99333f28b2b884f6e8be6477e4567732">RakPeerInterface::RegisterAsRemoteProcedureCall</a> (const char *uniqueID, void(*functionPointer)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms))=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gfe56a369e1b4396eaa4c771bf172d889">RakPeerInterface::RegisterClassMemberRPC</a> (const char *uniqueID, void *functionPointer)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#ge8f46abeff087cfa765beef89facef85">RakPeerInterface::UnregisterAsRemoteProcedureCall</a> (const char *uniqueID)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g2213ab20dee5f864383e559e3d8cac7e">RakPeerInterface::SetNetworkIDManager</a> (<a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *manager)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gc3bf2251be773829a7c7017a885a6570">RakPeerInterface::RPC</a> (const char *uniqueID, const char *data, unsigned int bitLength, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#ge644fc210e9237acd4fad227a0cf214c">RakPeerInterface::RPC</a> (const char *uniqueID, const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A system to call C or object member procudures on other systems, and even to return return values. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g70705f68c378bfaf9d854de1fe55431d"></a><!-- doxytag: member="RakNetTypes.h::REGISTER_CLASS_MEMBER_RPC" ref="g70705f68c378bfaf9d854de1fe55431d" args="(networkObject, className, functionName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGISTER_CLASS_MEMBER_RPC          </td>
          <td>(</td>
          <td class="paramtype">networkObject,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">className,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functionName&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;{union {void (__cdecl className::*cFunc)( <a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms ); void* voidFunc;}; cFunc=&amp;className::functionName; networkObject-&gt;RegisterClassMemberRPC(CLASS_MEMBER_ID(className, functionName),voidFunc);}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a member function of an instantiated object as a Remote procedure call. RPC member Functions MUST be marked __cdecl! 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>ObjectMemberRPC.cpp <b><a class="el" href="group__RAKNET__RPC.html#gcdb86b76f825bec13557202fff8fbab1">CLASS_MEMBER_ID</a></b> is a utility macro to generate a unique signature for a class and function pair and can be used for the Raknet functions RegisterClassMemberRPC(...) and RPC(...) <b><a class="el" href="group__RAKNET__RPC.html#g70705f68c378bfaf9d854de1fe55431d">REGISTER_CLASS_MEMBER_RPC</a></b> is a utility macro to more easily call RegisterClassMemberRPC </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkObject</em>&nbsp;</td><td>Your instance of <a class="el" href="classRakPeer.html">RakPeer</a>, <a class="el" href="classRakPeer.html">RakPeer</a>, or <a class="el" href="classRakPeer.html">RakPeer</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>className</em>&nbsp;</td><td>The class containing the function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionName</em>&nbsp;</td><td>The name of the function (not in quotes, just the name) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge8725bfeccab05a3422cde0923f176b3"></a><!-- doxytag: member="RakNetTypes.h::REGISTER_STATIC_RPC" ref="ge8725bfeccab05a3422cde0923f176b3" args="(networkObject, functionName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGISTER_STATIC_RPC          </td>
          <td>(</td>
          <td class="paramtype">networkObject,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functionName&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(networkObject)-&gt;RegisterAsRemoteProcedureCall((#functionName),(functionName))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RPC Function Implementation. 
<p>
Register a C function as a Remote procedure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkObject</em>&nbsp;</td><td>Your instance of <a class="el" href="classRakPeer.html">RakPeer</a>, <a class="el" href="classRakPeer.html">RakPeer</a>, or <a class="el" href="classRakPeer.html">RakPeer</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionName</em>&nbsp;</td><td>The name of the C function to call </td></tr>
  </table>
</dl>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>12/01/05 REGISTER_AS_REMOTE_PROCEDURE_CALL renamed to REGISTER_STATIC_RPC. Delete the old name sometime in the future </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdf209f7aefd451d95a1f322bd80295ed"></a><!-- doxytag: member="RakNetTypes.h::UNREGISTER_STATIC_RPC" ref="gdf209f7aefd451d95a1f322bd80295ed" args="(networkObject, functionName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNREGISTER_STATIC_RPC          </td>
          <td>(</td>
          <td class="paramtype">networkObject,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functionName&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(networkObject)-&gt;UnregisterAsRemoteProcedureCall((#functionName))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a remote procedure call RPC member Functions MUST be marked __cdecl! See the ObjectMemberRPC example. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkObject</em>&nbsp;</td><td>The object that manages the function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionName</em>&nbsp;</td><td>The function name </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g99333f28b2b884f6e8be6477e4567732"></a><!-- doxytag: member="RakPeerInterface::RegisterAsRemoteProcedureCall" ref="g99333f28b2b884f6e8be6477e4567732" args="(const char *uniqueID, void(*functionPointer)(RPCParameters *rpcParms))=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeerInterface::RegisterAsRemoteProcedureCall           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms)&nbsp;</td>
          <td class="paramname"> <em>functionPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a C or static member function as available for calling as a remote procedure call <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A null-terminated unique string to identify this procedure. See <a class="el" href="group__RAKNET__RPC.html#gfe56a369e1b4396eaa4c771bf172d889">RegisterClassMemberRPC()</a> for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionPointer(...)</em>&nbsp;</td><td>The name of the function to be used as a function pointer. This can be called whether active or not, and registered functions stay registered unless unregistered </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="gc253d708a039e60aa0aaafca3f9a1d41"></a><!-- doxytag: member="RakPeer::RegisterAsRemoteProcedureCall" ref="gc253d708a039e60aa0aaafca3f9a1d41" args="(const char *uniqueID, void(*functionPointer)(RPCParameters *rpcParms))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::RegisterAsRemoteProcedureCall           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms)&nbsp;</td>
          <td class="paramname"> <em>functionPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a C or static member function as available for calling as a remote procedure call <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A null-terminated unique string to identify this procedure. See <a class="el" href="group__RAKNET__RPC.html#gbd4e89c774e58f88754dfd6108b9c7d0">RegisterClassMemberRPC()</a> for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionPointer(...)</em>&nbsp;</td><td>The name of the function to be used as a function pointer. This can be called whether active or not, and registered functions stay registered unless unregistered </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#g99333f28b2b884f6e8be6477e4567732">RakPeerInterface</a>.
</div>
</div><p>
<a class="anchor" name="gfe56a369e1b4396eaa4c771bf172d889"></a><!-- doxytag: member="RakPeerInterface::RegisterClassMemberRPC" ref="gfe56a369e1b4396eaa4c771bf172d889" args="(const char *uniqueID, void *functionPointer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeerInterface::RegisterClassMemberRPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>functionPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a C++ member function as available for calling as a remote procedure call. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A null terminated string to identify this procedure. Recommended you use the macro REGISTER_CLASS_MEMBER_RPC to create the string. Use <a class="el" href="group__RAKNET__RPC.html#g99333f28b2b884f6e8be6477e4567732">RegisterAsRemoteProcedureCall()</a> for static functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionPointer</em>&nbsp;</td><td>The name of the function to be used as a function pointer. This can be called whether active or not, and registered functions stay registered unless unregistered with UnregisterAsRemoteProcedureCall </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>The sample ObjectMemberRPC.cpp </dd></dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#gbd4e89c774e58f88754dfd6108b9c7d0">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="gbd4e89c774e58f88754dfd6108b9c7d0"></a><!-- doxytag: member="RakPeer::RegisterClassMemberRPC" ref="gbd4e89c774e58f88754dfd6108b9c7d0" args="(const char *uniqueID, void *functionPointer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::RegisterClassMemberRPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>functionPointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a C++ member function as available for calling as a remote procedure call. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A null terminated string to identify this procedure. Recommended you use the macro REGISTER_CLASS_MEMBER_RPC to create the string. Use <a class="el" href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41">RegisterAsRemoteProcedureCall()</a> for static functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionPointer</em>&nbsp;</td><td>The name of the function to be used as a function pointer. This can be called whether active or not, and registered functions stay registered unless unregistered with UnregisterAsRemoteProcedureCall </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>The sample ObjectMemberRPC.cpp </dd></dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#gfe56a369e1b4396eaa4c771bf172d889">RakPeerInterface</a>.
</div>
</div><p>
<a class="anchor" name="ge644fc210e9237acd4fad227a0cf214c"></a><!-- doxytag: member="RakPeerInterface::RPC" ref="ge644fc210e9237acd4fad227a0cf214c" args="(const char *uniqueID, const RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, SystemAddress systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, RakNet::BitStream *replyFromTarget)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakPeerInterface::RPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime *&nbsp;</td>
          <td class="paramname"> <em>includedTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkID&nbsp;</td>
          <td class="paramname"> <em>networkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>replyFromTarget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a C function on the remote system that was already registered using RegisterAsRemoteProcedureCall. If you want that function to return data you should call RPC from that system in the same wayReturns true on a successful packet send (this does not indicate the recipient performed the call), false on failure <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A NULL terminated string identifying the function to call. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitLength</em>&nbsp;</td><td>The number of bits of <em>data</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced message, what channel to order these on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Who to send this message to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includedTimestamp</em>&nbsp;</td><td>Pass a timestamp if you wish, to be adjusted in the usual fashion as per ID_TIMESTAMP. Pass 0 to not include a timestamp. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>For static functions, pass UNASSIGNED_NETWORK_ID. For member functions, you must derive from <a class="el" href="classNetworkIDObject.html">NetworkIDObject</a> and pass the value returned by <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">NetworkIDObject::GetNetworkID</a> for that object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replyFromTarget</em>&nbsp;</td><td>If 0, this function is non-blocking. Otherwise it will block while waiting for a reply from the target procedure, which should be remotely written to <a class="el" href="structRPCParameters.html#a9b53e0363e45c95746d179a94fc64f2">RPCParameters::replyToSender</a> and copied to replyFromTarget. The block will return early on disconnect or if the sent packet is unreliable and more than 3X the ping has elapsed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on a successful packet send (this does not indicate the recipient performed the call), false on failure </dd></dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#gb07776a842829a0e911354e5657345d3">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="gc3bf2251be773829a7c7017a885a6570"></a><!-- doxytag: member="RakPeerInterface::RPC" ref="gc3bf2251be773829a7c7017a885a6570" args="(const char *uniqueID, const char *data, unsigned int bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, SystemAddress systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, RakNet::BitStream *replyFromTarget)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakPeerInterface::RPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>bitLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime *&nbsp;</td>
          <td class="paramname"> <em>includedTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkID&nbsp;</td>
          <td class="paramname"> <em>networkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>replyFromTarget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a C function on the remote system that was already registered using <a class="el" href="group__RAKNET__RPC.html#g99333f28b2b884f6e8be6477e4567732">RegisterAsRemoteProcedureCall()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A NULL terminated string identifying the function to call. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitLength</em>&nbsp;</td><td>The number of bits of <em>data</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced message, what channel to order these on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Who to send this message to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includedTimestamp</em>&nbsp;</td><td>Pass a timestamp if you wish, to be adjusted in the usual fashion as per ID_TIMESTAMP. Pass 0 to not include a timestamp. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>For static functions, pass UNASSIGNED_NETWORK_ID. For member functions, you must derive from <a class="el" href="classNetworkIDObject.html">NetworkIDObject</a> and pass the value returned by <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">NetworkIDObject::GetNetworkID</a> for that object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replyFromTarget</em>&nbsp;</td><td>If 0, this function is non-blocking. Otherwise it will block while waiting for a reply from the target procedure, which should be remotely written to <a class="el" href="structRPCParameters.html#a9b53e0363e45c95746d179a94fc64f2">RPCParameters::replyToSender</a> and copied to replyFromTarget. The block will return early on disconnect or if the sent packet is unreliable and more than 3X the ping has elapsed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on a successful packet send (this does not indicate the recipient performed the call), false on failure </dd></dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#g555a4471b9cc061f2253817e35561f0f">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="gb07776a842829a0e911354e5657345d3"></a><!-- doxytag: member="RakPeer::RPC" ref="gb07776a842829a0e911354e5657345d3" args="(const char *uniqueID, const RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, SystemAddress systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, RakNet::BitStream *replyFromTarget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::RPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime *&nbsp;</td>
          <td class="paramname"> <em>includedTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkID&nbsp;</td>
          <td class="paramname"> <em>networkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>replyFromTarget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a C function on the remote system that was already registered using RegisterAsRemoteProcedureCall. If you want that function to return data you should call RPC from that system in the same wayReturns true on a successful packet send (this does not indicate the recipient performed the call), false on failure <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>To use object member RPC (networkID!=UNASSIGNED_OBJECT_ID), The recipient must have called SetNetworkIDManager so the system can handle the object lookups </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A NULL terminated string identifying the function to call. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitLength</em>&nbsp;</td><td>The number of bits of <em>data</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced message, what channel to order these on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Who to send this message to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includedTimestamp</em>&nbsp;</td><td>Pass a timestamp if you wish, to be adjusted in the usual fashion as per ID_TIMESTAMP. Pass 0 to not include a timestamp. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>For static functions, pass UNASSIGNED_NETWORK_ID. For member functions, you must derive from <a class="el" href="classNetworkIDObject.html">NetworkIDObject</a> and pass the value returned by <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">NetworkIDObject::GetNetworkID</a> for that object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replyFromTarget</em>&nbsp;</td><td>If 0, this function is non-blocking. Otherwise it will block while waiting for a reply from the target procedure, which should be remotely written to <a class="el" href="structRPCParameters.html#a9b53e0363e45c95746d179a94fc64f2">RPCParameters::replyToSender</a> and copied to replyFromTarget. The block will return early on disconnect or if the sent packet is unreliable and more than 3X the ping has elapsed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on a successful packet send (this does not indicate the recipient performed the call), false on failure </dd></dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#ge644fc210e9237acd4fad227a0cf214c">RakPeerInterface</a>.
</div>
</div><p>
<a class="anchor" name="g555a4471b9cc061f2253817e35561f0f"></a><!-- doxytag: member="RakPeer::RPC" ref="g555a4471b9cc061f2253817e35561f0f" args="(const char *uniqueID, const char *data, unsigned int bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, SystemAddress systemAddress, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, RakNet::BitStream *replyFromTarget)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::RPC           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>bitLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime *&nbsp;</td>
          <td class="paramname"> <em>includedTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkID&nbsp;</td>
          <td class="paramname"> <em>networkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>replyFromTarget</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a C function on the remote system that was already registered using <a class="el" href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41">RegisterAsRemoteProcedureCall()</a>. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>To use object member RPC (networkID!=UNASSIGNED_OBJECT_ID), The recipient must have called SetNetworkIDManager so the system can handle the object lookups </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A NULL terminated string identifying the function to call. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitLength</em>&nbsp;</td><td>The number of bits of <em>data</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html">PacketPriority.h</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced message, what channel to order these on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Who to send this message to, or in the case of broadcasting who not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includedTimestamp</em>&nbsp;</td><td>Pass a timestamp if you wish, to be adjusted in the usual fashion as per ID_TIMESTAMP. Pass 0 to not include a timestamp. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>For static functions, pass UNASSIGNED_NETWORK_ID. For member functions, you must derive from <a class="el" href="classNetworkIDObject.html">NetworkIDObject</a> and pass the value returned by <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">NetworkIDObject::GetNetworkID</a> for that object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replyFromTarget</em>&nbsp;</td><td>If 0, this function is non-blocking. Otherwise it will block while waiting for a reply from the target procedure, which should be remotely written to <a class="el" href="structRPCParameters.html#a9b53e0363e45c95746d179a94fc64f2">RPCParameters::replyToSender</a> and copied to replyFromTarget. The block will return early on disconnect or if the sent packet is unreliable and more than 3X the ping has elapsed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on a successful packet send (this does not indicate the recipient performed the call), false on failure </dd></dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#gc3bf2251be773829a7c7017a885a6570">RakPeerInterface</a>.
</div>
</div><p>
<a class="anchor" name="g2213ab20dee5f864383e559e3d8cac7e"></a><!-- doxytag: member="RakPeerInterface::SetNetworkIDManager" ref="g2213ab20dee5f864383e559e3d8cac7e" args="(NetworkIDManager *manager)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeerInterface::SetNetworkIDManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used by Object member RPC to lookup objects given that object's ID Also used by the <a class="el" href="classReplicaManager.html">ReplicaManager</a> plugin <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>An</em>&nbsp;</td><td>instance of <a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> to use for the lookup. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#g3dd3a014e7e3ab37489fdc3d9c77d072">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="g3dd3a014e7e3ab37489fdc3d9c77d072"></a><!-- doxytag: member="RakPeer::SetNetworkIDManager" ref="g3dd3a014e7e3ab37489fdc3d9c77d072" args="(NetworkIDManager *manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetNetworkIDManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used by Object member RPC to lookup objects given that object's ID Also used by the <a class="el" href="classReplicaManager.html">ReplicaManager</a> plugin <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>An</em>&nbsp;</td><td>instance of <a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> to use for the loookup. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#g2213ab20dee5f864383e559e3d8cac7e">RakPeerInterface</a>.
</div>
</div><p>
<a class="anchor" name="ge8f46abeff087cfa765beef89facef85"></a><!-- doxytag: member="RakPeerInterface::UnregisterAsRemoteProcedureCall" ref="ge8f46abeff087cfa765beef89facef85" args="(const char *uniqueID)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeerInterface::UnregisterAsRemoteProcedureCall           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a C function as available for calling as a remote procedure call that was formerly registered with RegisterAsRemoteProcedureCall. Only call offline. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A string of only letters to identify this procedure. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="group__RAKNET__RPC.html#g8d3118ee980a05022b9dd53a54b1f139">RakPeer</a>.
</div>
</div><p>
<a class="anchor" name="g8d3118ee980a05022b9dd53a54b1f139"></a><!-- doxytag: member="RakPeer::UnregisterAsRemoteProcedureCall" ref="g8d3118ee980a05022b9dd53a54b1f139" args="(const char *uniqueID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::UnregisterAsRemoteProcedureCall           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a C function as available for calling as a remote procedure call that was formerly registered with RegisterAsRemoteProcedureCall. Only call offline. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueID</em>&nbsp;</td><td>A string of only letters to identify this procedure. Recommended you use the macro CLASS_MEMBER_ID for class member functions. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="group__RAKNET__RPC.html#ge8f46abeff087cfa765beef89facef85">RakPeerInterface</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Feb 15 01:46:45 2007 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
